# САОД. Часть 2.

[Первая часть курса](2024_spring.md)

## Что нужно знать перед началом курса?
- Структурное, процедурное, модульное программирование, ООП
- Ссылки (указатели), динамическая работа с памятью
- Списковые структуры, динамические массивы
- Поверхностное копирование, глубокое копирование
- Модульное тестирование, желательно уметь использовать фреимворки для модульных тестов
- Асимптотическая оценка сложности алгоритмов - BigO, в частности для часто используемых алгоритмов и операций со структурами данных.
- Практические приёмы измерения времени работы реализаций алгоритмов





# Лекция 1. Повторение. Деревья.
03 сентября
1. Повторение:
   - Сложность алгоритмов. Рекурсия.
   - Интерфейс, АТД.
   - Списки.
   - Стек. Очередь. Дек. Очередь с приоритетом.
   - Множество
   - Слайды: https://docs.google.com/presentation/d/1YEXijE-L6xtoXNAgLldPDsw_skUCQwc7e4XA5dC0obk/edit?usp=sharing
2. Обзор тем и заданий семестра
2. Деревья.\
Слайды: https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit?usp=sharing


### Задание Узел бинарного дерева
1. Разработать шаблонный класс TreeNode для представления *узла* бинарного дерева
    - Создать бинарное дерево из 5+ узлов, используйте динамическое выделение памяти;
    - Изобразить дерево любыми средствами (можно нарисовать прямо в коде);
    - Является ли дерево строгим, законченным (complete) или совершенным (perfect)?
    - Посмотреть содержимое любого из узлов;
    - Удалить все узлы.
2. Создать тестовые функции.
3. *Бонус: аналогично создайте структуру для узла n-арного дерева*

Закончите до 9 сентября


### Задание Алгоритмы для бинарного дерева
1. Реализовать три алгоритма обхода (NLR, LNR, LRN).
   Оформите алгоритмы в виде функций:
   - создания массива (списка) на основе обхода;
   - вывода содержимого узлов дерева;
   - применения функции к каждому узлу дерева. [https://en.cppreference.com/w/cpp/utility/functional/function]
   ...
2. На основе изученных алгоритмов обхода создайте
   - функцию удаления дерева 
   - функцию подсчёта узлов
   - функцию определения глубины дерева
   - функции печати данных дерева:
     - в произвольном порядке
     - в виде дерева [1]
4. Создайте тесты для функций. Рассмотрите различные варианты деревьев, крайние случаи: пустые деревья, деревья из одного узла, вырожденные деревья и т.д.
6. *Бонус: аналогично создайте алгоритмы для n-арного дерева*
5. *Бонус: опишите любую иерархическую структуру на основе собственного класса.*
   - реализуйте алгоритм обхода с применением функции к данным каждого узла
   - дополнительно: используйте узлы с произвольным числом потомков


Закончите до 16 сентября