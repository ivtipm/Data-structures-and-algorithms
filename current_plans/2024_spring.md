# Структуры и алгоритмы обработки данных

# Результат успешного прохождения курса
- Научитесь использовать оценку сложности алгоритмов BigO
- Изучите и реализуете алгоритмы поиска в последовательностях
- Изучите и реализуете алгоритмы сортировки последовательностей
- Познакомитесь с динамическими алгоритмами
- Познакомитесь с некоторыми алгоритмами обработки строк
- На практике примените многие концепции ООП, шаблонного программирования, модульного тестирования
- Изучите структуры данных изнутри, их сильные и слабые стороны, кейсы применения, реализуете эти структуры в виде классов
    - Динамический массив
    - Списки
    - Стек
    - Очередь
    - Дерево, бинарное дерево, бинарное дерево поиска
    - AVL дерево
    - Граф
    - Хеш-таблица
    - Словарь
    - ...
- ...


# План
## Лекция 1. Обзор курса. Сложность алгоритмов.
Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing


## Занятие 1.
Защита работ по ООП (если не сданы).

### Задание 0.
1. Раздобудьте рекомендованную литературу.

2. Если будете выполнять работы не на языке C++, то раздобудьте литературу по этому языку программирования. Там должны быть описаны основы языка: основы синтаксиса, типы данных, основные операторы, функции, методы, классы, модули, шаблонные классы и функции (или аналоги шаблонов), анонимные функции.

3. В течении курса можно предлагать свои варианты заданий, связанных с рассматриваемыми темами.

### Задание 1. Подготовительный код для работы с массивами, измерения времени; последовательный поиск
Используйте язык программирования С++. 
Документируйте код, указывайте автора, пишите поясняющие комментарии, не пишите весь код в одном файле. Приведите ссылку на это задание в главной файле программы, текст задания.
Для хранения размера массива, индексов стоит использовать тип `size_t`. Он может хранить только положительные значения из большого диапазона. 

Храните данные в классических массивах, не используйте библиотечные коллекции.


1. Напишите подготовительный код, используйте шаблонные [[OOP StudBook](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook_upd.pdf#section.2.3)] функции:
    - Шаблон кода для измерения времени работы участка кода. [OOP_StudBook.pdf: Время](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10)
    - Функцию создания массива заданного размера, заполненного случайными значениями в заданном интервале. [OOP_StudBook.pdf](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10);\
    Создайте функцию заполнения массива случайными числами, но монотонно возрастающими. Она поможет тестировать функции поиска, которые полагаются на отсортированный массив и сэкономит время работы программы, потому, что не потребуется дополнительная сортировка. 
    - Функцию вывода массива в файл.
    - Функцию, которая проверяет, отсортирован ли массив; напишите автоматические тесты для функции (assert).
    - *Дополнительно: для тестов используйте тестовый проект (например, на основе google test) в среде разработки.*
1. Реализуйте алгоритм последовательного поиска значения в массиве используя шаблонные функции. 
    - Протестируйте их на массивах большого размера. Измерьте время выполнения в зависимости от размера массива. Время должно быть как минимум порядка секунд, иначе результаты нельзя считать надёжными. На время выполнения вашей программы могут сильно влиять другие программы, работающие одновременно с ней. Запускайте операции много раз (в цикле) чтобы получить более надёжные измерения времени.
    - Приведите оценки сложности Big O реализованных алгоритмов для лучшего, среднего и худшего случая. Приведите графики этих оценок. Как сильно они отличаются от полученных?
1. upd: Бонус: реализуйте функцию последовательного поиска, которая вместо проверки на равенство (==) выполняет произвольную функцию f. Например сравнивает числа с заданной точностью; сравнивает строки без учёта начальных пробелов, регистра символов и т.д. Используйте анонимные функции [[OOP StudBook](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook_upd.pdf#subsection.2.2.3)], передавайте их в функцию последовательного поиска. В C++ для этого удобно использовать тип std::function. Напишите тесты для разных массивов и с разными функциями f.

**Измерение времени работы кода**
```cpp
#include <chrono>
using namespace std::chrono;


	auto t0 = steady_clock::now();
	
	// конечная отметка времени
	auto t1 = steady_clock::now();
	// преобразование времени (обычно наносекунды) в миллисекунды
	auto delta = duration_cast<milliseconds>(t1 - t0);
	std::cout << "time delta (milliseconds) " << delta.count()
```


Можно использовать этот пример кода на Питоне для построения графиков
```python
import matplotlib.pyplot as plt
import seaborn # pip install seaborn

plt.figure( figsize=(15, 10) )
plt.title("Среднее время работы сортировок")
plt.plot( [10, 100, 1000], [1, 2, 8], 'o--', label = "название сортировки 1" )
plt.plot( [10, 100, 1000], [2, 2, 9], 'o--', label = "название сортировки 2" )
plt.plot( [10, 100, 1000], [0.3, 3, 10], 'o--', label = "название сортировки 3" )
plt.grid(True)
plt.xlabel('размер массива')
plt.ylabel('среднее время (ед. измер)')
plt.legend(loc = 'best')
```
Для построения графиков можно использовать среду [google colaboratory](https://colab.research.google.com/) (требуется войти в аккаунт google).

См. [подсказки для Java](java_hints.md)


### Задание 2. Анализ сложности алгоритма.
Привидите ссылку на это задание в главной файле программы, текст задания.
[tasks/task_s1_alg_analysis](../tasks/task_s1_alg_analysis.md)



## Лекция 2. Рекурсия. Алгоритмы поиска
14 февраля
0. Повторение. Опрос. Оценка сложности алгоритмов. BigO. Классы сложности. Классы входных данных.
1. Рекурсия.
2. Рекурсия. Алгоритмы поиска.


Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing

### Задание 3. Бинарный поиск.
Приведите ссылку на это задание в главной файле программы, текст задания.
1. Реализуйте алгоритм бинарного поиска
1. Бонус: Реализуйте алгоритм интерполяционного поиска.
2. Напишите тесты.
3. Измерьте время работы алгоритмов. См замечание об измерении времени в задании 1. Постройте графики времени работы алгоритма. Сравните его с алгоритмом последовательного поиска. Стройте график последовательного поиска на отдельном полотне, если из-за разницы в масштабах времени он мешает рассмотреть график времени для бинарного поиска.
1. *upd*: Укажите оценку BigO для разных классов входных данных (худший, средний, лучший случаи), укажите оценку BigO для памяти. Проверьте, соответствуют ли графики времени работы алгоритмов одному из указанных классов? Какому? Почему?
4. Бонус: добавьте в программу интерфейс, использующий аргументы командной строки, для ввода входных данных или параметров их генерации.



Используйте код, созданный для задания 1.


### Задание 4. Размер стека вызовов
Оцените размер стека вызовов на своём компьютере. Создайте отчёт.\
Проверьте, какой размер имеет стек вызовов если компилировать программу вместе с отладочной информацией (режим debug) и без неё (режим release).


### Задание 5. [Рекурсия](../tasks/task_recursion.md)


## Лекция 3. Подходы к построению алгоритмов.
20 февраля
1. Повторение. Опрос. Время выполнения операций [ [слайд](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g2ba866ef3bc_0_0) ]
1. Жадные алгоритмы [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15) ].
1. Динамическое программирование [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15)].


### Домашнее задание (бонус). Mind map
К концу семестра создайте интеллект карту (mind-map), отражающую структуру дисциплины, важные понятия, литературу и другие источники.
Используйте изображения, схемы, ссылки, формулы, цветовое кодирование и т.д.

Создавайте диаграмму в специальной программе (онлайн-приложении), например  draw.io


## Лекция 4. Подходы к построению алгоритмов.
28 февраля
1. Повторение. Опрос. BigO vs Время выполнения запрограммированного алгоритма. Рекурсия. Проверка на палиндром. Программа time. Жадные алгоритмы.
2. Обзор заданий. [Шпаргалка по Java](java_hints.md). Задание 0 - литература. Указание сложности алгоритмов в документации к функциям. 
3. Динамическое программирование.
4. Алгоритмы типа Разделяй и властвуй.

См. в дискорде ссылку на запись занятия.


### Задание 6. Сортировки
1. Реализуйте алгоритмы сортировки 
    1. Сортировка слиянием. Создайте отдельную функцию для слияния двух отсортированных массивов. (*до 6 марта*).
    2. Один или несколько алгоритмов сортировки, работающих за $O(n^2)$ в среднем случае (*до 6 марта*).
    3. Быстрая сортировка (quick sort). Создайте отдельную функцию для сортировки массива(частичной) относительно опорного значения. (*до 13 марта*)
    4. Сортировка Шелла
    5. Бонус: Timsort
3. Напишите тесты.
4. Приведите в коде ссылку на это задание. Текст задания.\
   Документируйте функции, пишите пояснения к алгоритмам и коду.\
   Указывайте оценку BigO для временной сложности алгоритма для разных классов входных данных, оценку дополнительных затрат памяти.
5. Постройте график времени сортировки массива в зависимости от его размера
   1. Для реализованных алгоритмов. Сравните форму кривой с классом сложности BigO для среднего случая.
   2. Добавьте график времени работы для функции сортировки массива из стандартной библиотеки. Напишите, какой алгоритм эта функция реализует.
   * Учитывайте замечания к измерению времени работы функций из предыдущих заданий и лекций.
6. *Бонус: приведите пример и тест функции сортировки массива для произвольного собственного, не числового, типа данных.*

Создавайте шаблонные функции.

Задание может быть дополнено другими алгоритмами сортировки. Реализация по желанию.

### Задание. Жадные алгоритмы?

### [Задание 7. Динамическое программирование.](../tasks/task_s1_dynamic_programming.md)
Выполните задание за 1-2 недели, до 13 марта.




## Лекция 5.  Сортировки
6 марта
1. Повторение. Жадный алгоритм. Динамическое программирование. Разделяй и властвуй. Во сколько раз отличается оценка времени работы алгоритмов $O(log n)$, $O(n)$, $O(n^2)$ при n = 10, 100, 1e5?\
Как может отличается количество операций в алгоритмах, которые имеют оценку O( n log n)?
2. Сортировки. Свойства алгоритмов. Устойчивость. Внутренняя и внешняя сортировки. Ключи и значения. Быстрая сортировка (quicksort). Сортировка Шелла.


## Лекция 6. Структуры данных. Динимический массив.
13 марта
1. Обзор структур данных.
2. Динамический массив. Операции. Сложность операций.
Слайды: https://docs.google.com/presentation/d/1r-ZLt9NaR27Mye14m09YsyAFaPFAYlvOsd17qAr_cnY/edit?usp=sharing

### Задание. Динамический массив.
Реализуйте шаблонный класс динамический массив.  

До 27 марта? 

### Задание. Список?
До 27 марта? 

### Задание. Стек? и стековый калькулятор?
До 4 апреля?

### Задание. Очередь?
До 18 апреля?

### Задание. Поразрядная сортировка?

### Задание. Алгоритмы поиска в строке?

### Задание. Дек (deque)?
До 22 мая?

### Задание. Отчёт о алгоритмах, ручное применение алгоритма?
- Работа алгоритма бинарного поиска
- Работа алгоритма сортировки слиянием, сортировки вставками
- Работа стека
- ...
