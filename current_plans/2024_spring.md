# Структуры и алгоритмы обработки данных

# Результат успешного прохождения курса
- Научитесь использовать оценку сложности алгоритмов BigO
- Изучите и реализуете алгоритмы поиска в последовательностях
- Изучите и реализуете алгоритмы сортировки последовательностей
- Познакомитесь с динамическими алгоритмами
- Познакомитесь с некоторыми алгоритмами обработки строк
- На практике примените многие концепции ООП, шаблонного программирования, модульного тестирования
- Изучите структуры данных изнутри, их сильные и слабые стороны, кейсы применения, реализуете эти структуры в виде классов
    - Динамический массив
    - Списки
    - Стек
    - Очередь
    - Дерево, бинарное дерево, бинарное дерево поиска
    - AVL дерево
    - Граф
    - Хеш-таблица
    - Словарь
    - ...
- ...


# План
## Лекция 1. Обзор курса. Сложность алгоритмов.
Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing


## Занятие 1.
Защита работ по ООП (если не сданы).

### Задание 0.
1. Раздобудьте рекомендованную литературу.

2. Если будете выполнять работы не на языке C++, то раздобудьте литературу по этому языку программирования. Там должны быть описаны основы языка: основы синтаксиса, типы данных, основные операторы, функции, методы, классы, модули, шаблонные классы и функции (или аналоги шаблонов), анонимные функции.

3. В течении курса можно предлагать свои варианты заданий, связанных с рассматриваемыми темами.

### Задание 1. Подготовительный код для работы с массивами, измерения времени; последовательный поиск
Используйте язык программирования С++. 
Документируйте код, указывайте автора, пишите поясняющие комментарии, не пишите весь код в одном файле. Привидите ссылку на это задание в главной файле программы, текст задания.
Для хранения размера массива, индексов стоит использовать тип `size_t`. Он может хранить только положительные значения из большого диапазона. 

Храните данные в классических массивах, не используйте библиотечные коллекции.


1. Напишите подготовительный код, используйте шаблонные [[OOP StudBook](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook_upd.pdf#section.2.3)] функции:
    - Шаблон кода для измерения времени работы участка кода. [OOP_StudBook.pdf: Время](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10)
    - Функцию создания массива заданного размера, заполненного случайными значениями в заданном интервале. [OOP_StudBook.pdf](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10);\
    Создайте функцию заполнения массива случайными числами, но монотонно возрастающими. Она поможет тестировать функции поиска, которые полагаются на отсортированный массив и сэкономит время работы программы, потому, что не потребуется дополнительная сортировка. 
    - Функцию вывода массива в файл.
    - Функцию, которая проверяет, отсортирован ли массив; напишите автоматические тесты для функции (assert).
    - *Дополнительно: для тестов используйте тестовый проект (например, на основе google test) в среде разработки.*
1. Реализуйте алгоритм последовательного поиска значения в массиве используя шаблонные функции. 
    - Протестируйте их на массивах большого размера. Измерьте время выполнения в зависимости от размера массива. Время должно быть как минимум порядка секунд, иначе результаты нельзя считать надёжными. На время выполнения вашей программы могут сильно влиять другие программы, работающие одновременно с ней. Запускайте операции много раз (в цикле) чтобы получить более надёжные измерения времени.
    - Приведите оценки сложности Big O реализованных алгоритмов для лучшего, среднего и худшего случая. Приведите графики этих оценок. Как сильно они отличаются от полученных?
1. upd: Бонус: реализуйте функцию последовательного поиска, которая вместо проверки на равенство (==) выполняет произвольную функцию f. Например сравнивает числа с заданной точностью; сравнивает строки без учёта начальных пробелов, регистра символов и т.д. Используйте анонимные функции [[OOP StudBook](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook_upd.pdf#subsection.2.2.3)], передавайте их в функцию последовательного поиска. В C++ для этого удобно использовать тип std::function. Напишите тесты для разных массивов и с разными функциями f.

**Измерение времени работы кода**
```cpp
#include <chrono>
using namespace std::chrono;


	auto t0 = steady_clock::now();
	
	// конечная отметка времени
	auto t1 = steady_clock::now();
	// преобразование времени (обычно наносекунды) в миллисекунды
	auto delta = duration_cast<milliseconds>(t1 - t0);
	std::cout << "time delta (milliseconds) " << delta.count()
```


Можно использовать этот пример кода на Питоне для построения графиков
```python
import matplotlib.pyplot as plt
import seaborn # pip install seaborn

plt.figure( figsize=(15, 10) )
plt.title("Среднее время работы сортировок")
plt.plot( [10, 100, 1000], [1, 2, 8], 'o--', label = "название сортировки 1" )
plt.plot( [10, 100, 1000], [2, 2, 9], 'o--', label = "название сортировки 2" )
plt.plot( [10, 100, 1000], [0.3, 3, 10], 'o--', label = "название сортировки 3" )
plt.grid(True)
plt.xlabel('размер массива')
plt.ylabel('среднее время (ед. измер)')
plt.legend(loc = 'best')
```
Для построения графиков можно использовать среду [google colaboratory](https://colab.research.google.com/) (требуется войти в аккаунт google).

См. [подсказки для Java](java_hints.md)


### Задание 2. Анализ сложности алгоритма.
Привидите ссылку на это задание в главной файле программы, текст задания.
[tasks/task_s1_alg_analysis](../tasks/task_s1_alg_analysis.md)



## Лекция 2. Рекурсия. Алгоритмы поиска
14 февраля
0. Повторение. Опрос. Оценка сложности алгоритмов. BigO. Классы сложности. Классы входных данных.
1. Рекурсия.
2. Рекурсия. Алгоритмы поиска.


Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing

### Задание 3. Бинарный поиск.
Приведите ссылку на это задание в главной файле программы, текст задания.
1. Реализуйте алгоритм бинарного поиска
1. Бонус: Реализуйте алгоритм интерполяционного поиска.
2. Напишите тесты.
3. Измерьте время работы алгоритмов. См замечание об измерении времени в задании 1. Постройте графики времени работы алгоритма. Сравните его с алгоритмом последовательного поиска. Стройте график последовательного поиска на отдельном полотне, если из-за разницы в масштабах времени он мешает рассмотреть график времени для бинарного поиска.
1. *upd*: Укажите оценку BigO для разных классов входных данных (худший, средний, лучший случаи), укажите оценку BigO для памяти. Проверьте, соответствуют ли графики времени работы алгоритмов одному из указанных классов? Какому? Почему?
4. Бонус: добавьте в программу интерфейс, использующий аргументы командной строки, для ввода входных данных или параметров их генерации.



Используйте код, созданный для задания 1.


### Задание 4. Размер стека вызовов
Оцените размер стека вызовов на своём компьютере. Создайте отчёт.

### Задание 5. [Рекурсия](../tasks/task_recursion.md)


## Лекция 3. Подходы к построению алгоритмов.
20 февраля
1. Повторение. Опрос. Время выполнения операций [ [слайд](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g2ba866ef3bc_0_0) ]
1. Жадные алгоритмы [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15) ].
1. Динамическое программирование [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15)].


### Домашнее задание (бонус). Mind map
К концу семестра создайте интиллект карту (mind-map), отражающую структуру дисциплины, важные понятия, литературу и другие источники.
Используйте изображения, схемы, ссылки, формулы, цветовое кодирование и т.д.

Создавайте диаграмму в специальной программе (онлайн-приложении), например  draw.io


## Лекция 4. Подходы к построению алгоритмов.
28 февраля
1. Повторение. Опрос. BigO vs Время выполнения запрограммированного алгоритма. Рекурсия. Проверка на палиндром. Программа time. Жадные алгоритмы.
2. Обзор заданий. [Шпарагалка по Java](java_hints.md). Задание 0 - литература. Указание сложности алгоритмов в документации к функциям. 
3. Динамическое программирование.
4. Алгоритмы типа Разделяй и влавствуй.

### Задание 6. Сортировки
1. Реализуйте алгоритм сортировки слиянием. Создайте отдельную функцию для слияния двух отсортированных массивов.
2. Реализуйте один или несколько алгоритмов сортировки, работающих за $O(n^2)$ в среднем случае.
3. Напишите тесты.
4. Документируйте функции, пишите пояснения к алгоритмам и коду.
5. Постройте график времени сортировки массива в зависимости от его размера
   1. Для реализованных алгоритмов. Сравните форму кривой с классом сложности BigO для среднего случая.
   2. Добавьте график времени работы для функции сортировки массива из стандартной библиотеки. Напишите, какой алгоритм эта функция реализует.

Создавайте шаблонные функции.

Задание будет дополнено другими алгоритмами сортировки.

### Задание 6. Жадные алгоритмы?

### Задание 7. Динамическое программирование?

### Задание. Сортировки.
1. Реализация алгоритмов сортировки.
1. Анализ времени, в том числе сравнение с библиотечной функцией сортировки.

### Задание. Список?

### Задание. Стек?

### Задание. Очередь?

### Задание. Поразрядная сортировка?

### Задание. Алгоритмы поиска в строке?

### Задание 11. Дек (deque)?
