# Структуры и алгоритмы обработки данных

# Результат успешного прохождения курса
- Научитесь использовать оценку сложности алгоритмов BigO
- Изучите и реализуете алгоритмы поиска в последовательностях
- Изучите и реализуете алгоритмы сортировки последовательностей
- Познакомитесь с динамическими алгоритмами
- Познакомитесь с некоторыми алгоритмами обработки строк
- На практике примените многие концепции ООП, шаблонного программирования, модульного тестирования
- Изучите структуры данных изнутри, их сильные и слабые стороны, кейсы применения, реализуете эти структуры в виде классов
    - Динамический массив
    - Списки
    - Стек
    - Очередь
    - Дерево, бинарное дерево, бинарное дерево поиска
    - AVL дерево
    - Граф
    - Хеш-таблица
    - Словарь
    - ...
- ...


# План
## Лекция 1. Обзор курса. Сложность алгоритмов.
Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing
- О курсе. Введение. Понятие алгоритма. 
- Сложность алгоритмов. 
    - Асимптотическая оценка: Нижняя, верхняя (bigO), точная. 
    - Классы сложности: константный, логарифмический, линейный, …
    - Классы входных данных: худший, средний, лучший.
    - Примеры оценки алгоритмов c помощью BigO.
- Оценка времени работы алгоритма. Время выполнения типичных операций (арифметика, обращение к RAM, кешу ЦП, …).
- Повторение (см. ООП) создание автоматических тестов.



## Занятие 1.
Защита работ по ООП (если не сданы).

### Задание 0.
1. Раздобудьте рекомендованную литературу.

2. Если будете выполнять работы не на языке C++, то раздобудьте литературу по этому языку программирования. Там должны быть описаны основы языка: основы синтаксиса, типы данных, основные операторы, функции, методы, классы, модули, шаблонные классы и функции (или аналоги шаблонов), анонимные функции.

3. В течении курса можно предлагать свои варианты заданий, связанных с рассматриваемыми темами.

### Задание 1. Подготовительный код для работы с массивами, измерения времени; последовательный поиск
Используйте язык программирования С++. 
Документируйте код, указывайте автора, пишите поясняющие комментарии, не пишите весь код в одном файле. Приведите ссылку на это задание в главной файле программы, текст задания.
Для хранения размера массива, индексов стоит использовать тип `size_t`. Он может хранить только положительные значения из большого диапазона. 

Храните данные в классических массивах, не используйте библиотечные коллекции.


1. Напишите подготовительный код, используйте шаблонные [[OOP StudBook](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook_upd.pdf#section.2.3)] функции:
    - Шаблон кода для измерения времени работы участка кода. [OOP_StudBook.pdf: Время](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10)
    - Функцию создания массива заданного размера, заполненного случайными значениями в заданном интервале. [OOP_StudBook.pdf](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10);\
    Создайте функцию заполнения массива случайными числами, но монотонно возрастающими. Она поможет тестировать функции поиска, которые полагаются на отсортированный массив и сэкономит время работы программы, потому, что не потребуется дополнительная сортировка. 
    - Функцию вывода массива в файл.
    - Функцию, которая проверяет, отсортирован ли массив; напишите автоматические тесты для функции (assert).
    - *Дополнительно: для тестов используйте тестовый проект (например, на основе google test) в среде разработки.*
1. Реализуйте алгоритм последовательного поиска значения в массиве используя шаблонные функции. 
    - Протестируйте их на массивах большого размера. Измерьте время выполнения в зависимости от размера массива. Время должно быть как минимум порядка секунд, иначе результаты нельзя считать надёжными. На время выполнения вашей программы могут сильно влиять другие программы, работающие одновременно с ней. Запускайте операции много раз (в цикле) чтобы получить более надёжные измерения времени.
    - Приведите оценки сложности Big O реализованных алгоритмов для лучшего, среднего и худшего случая. Приведите графики этих оценок. Как сильно они отличаются от полученных?
1. upd: Бонус: реализуйте функцию последовательного поиска, которая вместо проверки на равенство (==) выполняет произвольную функцию f. Например сравнивает числа с заданной точностью; сравнивает строки без учёта начальных пробелов, регистра символов и т.д. Используйте анонимные функции [[OOP StudBook](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook_upd.pdf#subsection.2.2.3)], передавайте их в функцию последовательного поиска. В C++ для этого удобно использовать тип std::function. Напишите тесты для разных массивов и с разными функциями f.

**Измерение времени работы кода**
```cpp
#include <chrono>
using namespace std::chrono;


	auto t0 = steady_clock::now();
	
	// конечная отметка времени
	auto t1 = steady_clock::now();
	// преобразование времени (обычно наносекунды) в миллисекунды
	auto delta = duration_cast<milliseconds>(t1 - t0);
	std::cout << "time delta (milliseconds) " << delta.count()
```


Можно использовать этот пример кода на Питоне для построения графиков
```python
import matplotlib.pyplot as plt
import seaborn # pip install seaborn

plt.figure( figsize=(15, 10) )
plt.title("Среднее время работы сортировок")
plt.plot( [10, 100, 1000], [1, 2, 8], 'o--', label = "название сортировки 1" )
plt.plot( [10, 100, 1000], [2, 2, 9], 'o--', label = "название сортировки 2" )
plt.plot( [10, 100, 1000], [0.3, 3, 10], 'o--', label = "название сортировки 3" )
plt.grid(True)
plt.xlabel('размер массива')
plt.ylabel('среднее время (ед. измер)')
plt.legend(loc = 'best')
```
Для построения графиков можно использовать среду [google colaboratory](https://colab.research.google.com/) (требуется войти в аккаунт google).

См. [подсказки для Java](java_hints.md)


### Задание 2. Анализ сложности алгоритма.
Привидите ссылку на это задание в главной файле программы, текст задания.
[tasks/task_s1_alg_analysis](../tasks/task_s1_alg_analysis.md)



## Лекция 2. Рекурсия. Алгоритмы поиска
14 февраля
0. Повторение. Опрос. Оценка сложности алгоритмов. BigO. Классы сложности. Классы входных данных.
1. Рекурсия. Базовый случай. Дерево рекурсии. Рекурсия vs цикл. Хвостовая рекурсия. Стек вызовов. Проблема переполнения стека вызовов. Примеры: Факториал, числа Фибоначчи, ханойские башни.
2. Последовательный поиск, бинарный поиск, интерполяционный поиск. Использование рекурсии в алгоритмах поиска.

См. также распределяющий поиск.


Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing

### Задание 3. Бинарный поиск
Приведите ссылку на это задание в главной файле программы, текст задания.
1. Реализуйте алгоритм бинарного поиска
1. Бонус: Реализуйте алгоритм интерполяционного поиска.
2. Напишите тесты.
3. Измерьте время работы алгоритмов. См замечание об измерении времени в задании 1. Постройте графики времени работы алгоритма. Сравните его с алгоритмом последовательного поиска. Стройте график последовательного поиска на отдельном полотне, если из-за разницы в масштабах времени он мешает рассмотреть график времени для бинарного поиска.
1. *upd*: Укажите оценку BigO для разных классов входных данных (худший, средний, лучший случаи), укажите оценку BigO для памяти. Проверьте, соответствуют ли графики времени работы алгоритмов одному из указанных классов? Какому? Почему?
4. Бонус: добавьте в программу интерфейс, использующий аргументы командной строки, для ввода входных данных или параметров их генерации.
1. *upd: Бонус. Сравните время работы с функцией последовательного поиска из стандартной библиотеки*



Используйте код, созданный для задания 1.


### Задание 4. Размер стека вызовов
Оцените размер стека вызовов на своём компьютере. Создайте отчёт.\
Проверьте, какой размер имеет стек вызовов если компилировать программу вместе с отладочной информацией (режим debug) и без неё (режим release).


### Задание 5. [Рекурсия](../tasks/task_recursion.md)


## Лекция 3. Подходы к построению алгоритмов.
20 февраля
1. Повторение. Опрос. Время выполнения операций [ [слайд](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g2ba866ef3bc_0_0) ]
1. Жадные алгоритмы [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15) ].
1. Динамическое программирование [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15)].


### Домашнее задание (бонус). Mind map
К концу семестра создайте интеллект карту (mind-map), отражающую структуру дисциплины, важные понятия, литературу и другие источники.
Используйте изображения, схемы, ссылки, формулы, цветовое кодирование и т.д.

Создавайте диаграмму в специальной программе (онлайн-приложении), например  draw.io


## Лекция 4. Подходы к построению алгоритмов.
28 февраля
1. Повторение. Опрос. BigO vs Время выполнения запрограммированного алгоритма. Рекурсия. Проверка на палиндром. Программа time. Жадные алгоритмы.
2. Обзор заданий. [Шпаргалка по Java](java_hints.md). Задание 0 - литература. Указание сложности алгоритмов в документации к функциям. 
3. Динамическое программирование.
4. Алгоритмы типа Разделяй и властвуй.

См. в дискорде ссылку на запись занятия.


### Задание 6. Сортировки
1. Реализуйте алгоритмы сортировки 
    1. Сортировка слиянием. Создайте отдельную функцию для слияния двух отсортированных массивов. (*до 6 марта*).
    2. Один или несколько алгоритмов сортировки, работающих за $O(n^2)$ в среднем случае (*до 6 марта*).
    3. Быстрая сортировка (quick sort). Создайте отдельную функцию для сортировки массива(частичной) относительно опорного значения. (*до 13 марта*)
    4. Сортировка Шелла
    5. Бонус: Timsort
3. Напишите тесты.
4. Приведите в коде ссылку на это задание. Текст задания.\
   Документируйте функции, пишите пояснения к алгоритмам и коду.\
   Указывайте оценку BigO для временной сложности алгоритма для разных классов входных данных, оценку дополнительных затрат памяти.
5. Постройте график времени сортировки массива в зависимости от его размера
   1. Для реализованных алгоритмов. Сравните форму кривой с классом сложности BigO для среднего случая.
   2. Добавьте график времени работы для функции сортировки массива из стандартной библиотеки. Напишите, какой алгоритм эта функция реализует.
   * Учитывайте замечания к измерению времени работы функций из предыдущих заданий и лекций.
6. *Бонус: приведите пример и тест функции сортировки массива для произвольного собственного, не числового, типа данных.*
1. *upd: Бонус. Сравните время работы с функцией сортировки из стандартной библиотеки*

Создавайте шаблонные функции.

Задание может быть дополнено другими алгоритмами сортировки. Реализация по желанию.

### Задание. Жадные алгоритмы?

### [Задание 7. Динамическое программирование.](../tasks/task_s1_dynamic_programming.md)
Выполните задание за 1-2 недели, до 13 марта.




## Лекция 5.  Сортировки
6 марта
1. Повторение. Жадный алгоритм. Динамическое программирование. Разделяй и властвуй. Во сколько раз отличается оценка времени работы алгоритмов $O(log n)$, $O(n)$, $O(n^2)$ при n = 10, 100, 1e5?\
Как может отличается количество операций в алгоритмах, которые имеют оценку O( n log n)?
2. Сортировки. Свойства алгоритмов. Устойчивость. Внутренняя и внешняя сортировки. Ключи и значения. Быстрая сортировка (quicksort). Сортировка Шелла.

См. запись лекции в дискорде.

## Лекция 6. Структуры данных. Динамический массив.
13 марта
1. Обзор структур данных.
2. Динамический массив. Операции. Сложность операций.
Слайды: https://docs.google.com/presentation/d/1r-ZLt9NaR27Mye14m09YsyAFaPFAYlvOsd17qAr_cnY/edit?usp=sharing

См. запись лекции в дискорде.


### Задание. Динамический массив.
1. Реализуйте шаблонный класс динамический массив.
    Необходимый минимум операций:
    - резервирование памяти в конструкторе
    - добавление элемента в конец
    - удаление последнего элемента
    - доступ по индексу (для чтения\изменения)\
    Предусмотрите увеличение размера массива при добавлении нового элемента в уже заполненный массив. Освобождение ненужной памяти при удалении большого количества элементов.
    Как должна быть реализована операция присваивания (копирования)? Что такое глубокое и поверхностное копирование?
    Если реализуете код на С++, то подумайте о правилах большой тройки\пятёрки.
2. Дополнительные операции:
    - Здание размера
    - удаление из середины массива
    - вставка элемента в середину массива
    - поиск элементов (может быть функцией)
    - сортировка (может быть функцией)
3. Напишите тесты.
3. Следующее задание посвящено созданию класса для связного списка. Подумайте, можно ли для класса динамический массив и связный список сделать общий интерфейс (абстрактный класс)? Реализуйте его, если задуманные Вами классы имеют схожий интерфейс. 

До 27 марта. 


## Лекция 7. Структуры данных. Списки
- Виды списков
- Операции
- Класс узла связного списка
- Класс списка
- Сравнение с массивом

См. также: кольцевой список, задача Иосифа Флавия.

См. ссылку на запись в дискорде

### Задание. Список
1. Реализуйте шаблонный класс Двусвязный список, операции:
    - Поиск элемента; average O(n)
    - Вставка элемента (начало – O(1); середина, конец O(n))
    - Удаление элемента (начало – O(1); середина, конец O(n))
    - Объединение (конкатенация) списков; O(n);
    - Получение размера; O(n)


До 03 апреля?


## Лекция 8. Структуры данных. Списки (продолжение). Поисковые структуры данных. Skip List
27 марта
1. Повторене. Бинарный поиск. Алгоритмы сортировки. Список (обход, добавление в ..., удаление из ..., поиск). Список vs Динамический массив. Глубокое и поверхностное копирование.
2. Поисковые структуры данных: сортированный массив, сортированный список, Skip List.

Слайды: https://docs.google.com/presentation/d/1r-ZLt9NaR27Mye14m09YsyAFaPFAYlvOsd17qAr_cnY/edit?usp=sharing

## Лекция 9. Структуры данных. Стек
4 апреля
1. Skip List. Продолжение. Вставка. Удаление.
2. Стек. FILO. 
    - Операции(push, pop, peek\top, isEmpty). Сложность операций. 
    - Реализация: на основе списка и массива.
    - Примеры использования.
3.  Формы записи арифметических выражений: Инфиксная, Префиксная (Польская), 
Постфиксная (Обратная Польская). Вычисление постфиксных выражений с использованием стека. (см. также вычисление инфиксных выражений с использованием стека операций и операндов).

См. также: Обратная польская нотация.
Проверка правильности скобочной последовательности. 
Реализация функции вызовов (call stack). 
Поддержка “Отменить” в текстовых редакторах.

См. запись лекции в дискорде


## Задание. Анализ средней сложности?
1. Изучите в литературе анализ средней сложности алгоритмов: бинарного поиска, быстрой сортировки, сортировки слиянием?
2. Изучите в литературе амортизационный анализ алгоритма добавления элементов в конец динамического массива (с перевыделением памяти).




### Задание. Стек? и стековый калькулятор?
До 4 апреля?

## Лекция 10. Очереди.
11 апреля
1. Повторение.
2. Очередь. FIFO.
    - Операции: enqueue, dequeue, front\peek, isEmpty. Сложность.
    - Очередь на основе кольцевого массива.
    - Реализация: на основе списка и на основе массива
3. Поразрядная сортировка.
- Слайды: https://docs.google.com/presentation/d/1e4ik9m7bWxDKmJfleoDN0XXzaF_DAx7W5EYHnyczag8

См. также: Использование очереди в системах обработки задач (Job Scheduling),
Использование очереди в алгоритмах обхода графов (BFS), 
Использование очереди в симуляции реального времени (Real-time simulation), Моделирование систем массового обслуживания (СМО) на основе очереди с приоритетами.

См. запись лекции в дискорде


### Задание. Очередь.
До 25 апреля.


## Лекция 11. Очереди (продолжение)
17 апреля
1. Повторение. Очередь vs Stack. Кольцевой буфер. Поразрядная сортировка.
3. Двусторонняя очередь (дек, deque)
4. Очередь с приоритетом (Priority Queue).

5. См. запись лекции в дискорде


### Задание. Поразрядная сортировка (бонус)
1. Реализуйте алгоритм. Документируйте код. Укажите сложность по памяти и по времени. +1 балл если используете собственный класс для очереди.
2. Напишите тесты.
3. Постройте график времени работы алгоритма. Сравните его с графикой функции, описывающей BigO для среднего случая. Сравните график с остальными из задания про сортировки.

## Лекция 12. Строки. Алгоритмы поиска в строках.
Слайды: https://docs.google.com/presentation/d/1WTfJh4NlN_CYkS8C-CWNv6YdTa0_bnKaakmvkgdpuq4

См. запись лекции в дискорде

### Задание. Алгоритм поиска в строке
1. Реализуйте наивный алгоритм поиска подстроки в строке.
1. Реализуйте алгоритм КМП для последовательности, используйте шаблонные типы.
2. Напишите тесты.
3. Измерьте среднее время работы алгоритма на данных (длинной более миллиона символов):
    - случайные последовательности,
    - поиск слов в тексте на естественном языке,
    - случайные последовательности из алфавита A,C,G,T
4. Постройте графики времени работы алгоритмов в зависимости от длины последовательности текста на естественном языке.


### Задание. Класс строки. Бонус
1. Реализуйте класс Строка. Реализуйте рекомендуемые в слайдах лекции операции, включая поиск подстроки алгоритмом КМП.
2. Напишите тесты.
 

### Задание. Дек (deque)
До 22 мая.


## Лекция 13. Строки. Продолжение. Множества.
- Строки, слайды: https://docs.google.com/presentation/d/1WTfJh4NlN_CYkS8C-CWNv6YdTa0_bnKaakmvkgdpuq4
- Множества, слайды: 




### Задание. Отчёт о алгоритмах, ручное применение алгоритма?
- Работа алгоритма бинарного поиска
- Работа алгоритма сортировки слиянием, сортировки вставками
- Работа стека
- ...
