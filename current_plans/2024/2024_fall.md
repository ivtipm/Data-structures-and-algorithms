# САОД. Часть 2.

[Первая часть курса](2024_spring.md)

## Что нужно знать перед началом курса?
- Структурное, процедурное, модульное программирование, ООП
- Ссылки (указатели), динамическая работа с памятью
- Списковые структуры, динамические массивы
- Поверхностное копирование, глубокое копирование
- Модульное тестирование, желательно уметь использовать фреимворки для модульных тестов
- Асимптотическая оценка сложности алгоритмов - BigO, в частности для часто используемых алгоритмов и операций со структурами данных.
- Практические приёмы измерения времени работы реализаций алгоритмов


# Лекция 4. Итераторы
1 октября
 - Указатели и адресная арифметика. Итераторы в STL. 
   - Слайды: https://docs.google.com/presentation/d/19OpCSfT8RM0c-lcAHhLHUM8s7jXqf_skliTnSj3RCCg/edit?usp=sharing
   - Пример итератора для массива.

### Задание. Итераторы
1. Создайте пример использования функций из модуля algorithms: for_each, any_of \ all_of \ none_of, transform, copy_if
1. Разработайте итератор для класса списка (LinkedList).
2. Разработайте итератор для класса Бинарное дерево.
3. *Бонус: Используйте цикл по коллекции `for( x : collection)` для перебора элементов*


# Лекция 2-3. Бинарное дерево поиска
10 сентября, 24 сентября 
- Повторение
- Операции поиска, вставки и удаления
- Пример класса с оператором сравнения
- Сложность операций?
Слайды: https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit?usp=sharing

### Задание. Бинарное дерево  поиска
- Реализуйте бинарное дерево поиска. Создайте тесты.
- upd: Дополните документацию оценкой сложности алгоритма BigO
- upd: постройте графики времени поиска в
   - сортированном массиве
   - BST
- *Бонус: показать операции BST на примере данных в виде произвольного класса с операторами (методами) сравнения.*

# Лекция 1. Повторение. Деревья.
03 сентября
1. Повторение:
   - Сложность алгоритмов. Рекурсия.
   - Интерфейс, АТД.
   - Списки.
   - Стек. Очередь. Дек. Очередь с приоритетом.
   - Множество
   - Слайды: https://docs.google.com/presentation/d/1YEXijE-L6xtoXNAgLldPDsw_skUCQwc7e4XA5dC0obk/edit?usp=sharing
2. Обзор тем и заданий семестра
2. Деревья.\
Слайды: https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit?usp=sharing


### Задание Узел бинарного дерева
1. Разработать шаблонный класс TreeNode для представления *узла* бинарного дерева
    - Создать бинарное дерево из 5+ узлов, используйте динамическое выделение памяти;
    - Изобразить дерево любыми средствами (можно нарисовать прямо в коде);
    - Является ли дерево строгим, законченным (complete) или совершенным (perfect)?
    - Посмотреть содержимое любого из узлов;
    - Удалить все узлы.
2. Создать тестовые функции.
3. *Бонус: аналогично создайте структуру для узла n-арного дерева*

Закончите до 9 сентября


### Задание Алгоритмы для бинарного дерева
1. Реализовать три алгоритма обхода (NLR, LNR, LRN).
   Оформите алгоритмы в виде функций:
   - создания массива (списка) на основе обхода;
   - вывода содержимого узлов дерева;
   - применения функции к каждому узлу дерева. [https://en.cppreference.com/w/cpp/utility/functional/function]
   ...
2. На основе изученных алгоритмов обхода создайте
   - функцию удаления дерева 
   - функцию подсчёта узлов
   - функцию определения глубины дерева
   - функции печати данных дерева:
     - в произвольном порядке
     - в виде дерева [1]
4. Создайте тесты для функций. Рассмотрите различные варианты деревьев, крайние случаи: пустые деревья, деревья из одного узла, вырожденные деревья и т.д.
5. Документируйте код, BigO для операций 
6. *Бонус: аналогично создайте алгоритмы для n-арного дерева*
5. *Бонус: опишите любую иерархическую структуру на основе собственного класса.*
   - реализуйте алгоритм обхода с применением функции к данным каждого узла
   - дополнительно: используйте узлы с произвольным числом потомков


Закончите до 16 сентября
