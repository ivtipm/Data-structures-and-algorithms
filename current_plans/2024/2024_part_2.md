# САОД. Часть 2.

# Общие сведения о курсе
[Первая часть курса](2024_spring.md)

## Что нужно знать перед началом курса?
- Структурное, процедурное, модульное программирование, ООП
- Ссылки (указатели), динамическая работа с памятью
- Списковые структуры, динамические массивы
- Поверхностное копирование, глубокое копирование
- Модульное тестирование, желательно уметь использовать фреимворки для модульных тестов
- Асимптотическая оценка сложности алгоритмов - BigO, в частности для часто используемых алгоритмов и операций со структурами данных.
- Практические приёмы измерения времени работы реализаций алгоритмов

## Экзамен

- Два теоретических вопроса и одно практическое задание в билете. Вопросы включат темы двух частей этого курса.
- Во время подготовки к ответу можно пользоваться любыми источниками.
- Во время ответа можно пользоваться только собственными конспектами, работами и тем материалом, что вы собрали при подготовке к ответы по билету.
- Будьте готовы воспроизвести код, который демонстрируете
- Обязательно объясняйте работу алгоритмов или структур данных на примерах. Преподаватель может предложить свои примеры.

Условия допуска (набор необходимых работ и дополнительных работ) на экзамен см. в таблице с отметками.


# О заданиях
В течении курса можно предлагать свои варианты заданий, связанных с рассматриваемыми темами.

Часть работ, связанных с деревьями и хеш-таблицами пригодиться вам на курсе по теории языков программирования.

# План
См. записи лекций в дискорде или ТГ канале


# Бонусное домашнее задание MindMap
- Бонус: Создайте интеллект-карту или другую диаграмму, описывающую содержание второй части данного курса.
- Дополнительный балл за диаграмму, описывающую курс целиком.\
Задание можно выполнять в парах.


# Домашнее задание: конспект по коллекциям в вашем любимом языке программирования
Бонус: Опишите коллекции из стандартной библиотеки (и других популярных библиотек при необходимости).
Приведите алгоритмическую сложность и оценку расхода памяти. Опишите внутреннее устройство коллекций.
Потокобезопасны ли эти коллекции?


# Лекция 11-12. Алгоритмы для файлов. Кэширование 
10 и 17 декабря
- Операции с файлами. Бинарные и текстовые файлы.
- Поиск в файлах: последовательный, бинарный и по индексам
- Внешняя сортировка на основе сортировки слиянием
- Кэшироние. Основные понятия. Алгоритмы LRU, LFU, FIFI. Пример примитивного кэширования запросов для СУБД SQLite.
Слайды: https://docs.google.com/presentation/d/1MpLxGfosg8uDUp_R6lBHsF8h2oorteNPI-9_4QudKio/edit?usp=sharing


### Бонусное домашнее задание Кэширование
1. Создайте класс для одного из рассмотренных алгоритмов кэширования (LRU, LFU, FIFO или др.)
2. Примените алгоритм для решения реальной задачи. Например кэшируйте результаты запросов к БД SQLite, 
3. Сравните среднее время получения результатов без кэшироваия с кэшированием.


### Бонусное домашнее задание: Внешняя сортировка
1. Реализуйте один из алгоритмов внешней сортировки
2. Протестируйте на файлах большого объёма, в том числе на файлах которые целиком не помещаются в  оперативную память.

В качестве примера файлов можно использовать текстовые или бинарные файлы с числовыми данными, выгрузки таблиц из БД или файлы с табличными данными, сгенерироваными автоматически.

# Бонусное домашнее задание: Поиск в файлах через индекс
1. Реализуйте класс для поиска в текстовых файлах через полный или частичный индекс
2. Протестируйте поиск на файлах большого объёма (сотни мегабайт)
3. Сравните время поиска с использованием индекса и последовательного поиска.



### [Домашнее задание Закон ципфа](../../tasks/zipfs_law.md)


### Бонусное домашнее задание Множество
1. Реализуйте класс Множество на основе самобалансирующегося бинарного дерева поиска или хеш-таблицы
2. Бонус: реализуйте множество вторым способом 
3. *Реализуйте итератор для этой коллекции*

### Бонусное домашнее задание Множество
1. Реализуйте класс Множество на основе самобалансирующегося бинарного дерева поиска или хеш-таблицы
2. Бонус: реализуйте множество вторым способом 
3. *Реализуйте итератор для этой коллекции*

### Бонусное домашнее задание Словарь
1. Реализуйте класс Словарь на основе самобалансирующегося бинарного дерева поиска или хеш-таблицы
2. Бонус: реализуйте словарь вторым способом 
3. *Реализуйте итератор для этой коллекции*

# Лекция 9-10. Хеш-таблицы
19 ноября, 26 октября
- Понятие хеш-таблицы. Хеш-функция. Необходимые и желательные свойтсва
- Слайды: https://docs.google.com/presentation/d/1jq7X0UgyPB093EKQ-AQZw3fGUR4N1u8Cg2g96OVSou8/edit?usp=sharing

### Бонусное домашнее задание Хеш-таблица
1. Реализуйте шаблонный класс хеш-таблица. Предусмотрите задание произвольной хеш-функции. Не используйте простые хеш-функции, в 1-2 действия.
   - Охарактеризуйте выбранную хеш-функцию. Будет ли распределение её значений равномерным?
   - Бонус: постройте график распределения выбранной (или нескольких) хеш функций.
   - Дополнительный балл за изменяемую хеш-таблицу (рехеширование)
2. *Бонус: Реализуйте итератор для этой коллекции*


### Бонусное домашнее задание: построение графов
- Постройте граф социальных связей на основе данных из социальной сети.
   - Спрашивайте данные, код для их получения у преподавателя
   - Можно предложить свои данные
   - Охарактеризуйте граф: много ли там изолянтов? Есть ли там кластеры? Чем они характеризуются?
   - Проведите позиционный анализ
- Постройте граф сообществ из социальной сети
   - Спрашивайте данные, код для их получения у преподавателя
   - Можно предложить свои данные
   - Ребро в графе может обозначать наличие одних и тех же подписчиков или схожесть групп по темам. Для определения схожести тем можно использовать векторное представления описания, содержания групп на основе нейросетевых моделей типа Sentence Embeddings. 
- Постройте граф описывающий публикации их связи по соавторам или темам. 
   - Рассмотрите сборники публикаций местных научно-практических конференций или публикаций на ваш выбор.
   - Для определения схожести тем можно использовать векторное представления описания, содержания групп на основе нейросетевых моделей типа Sentence Embeddings. 
 

### Домашнее задание. Граф
1. Реализуйте класс "граф" согласно АТД, приведённому на слайдах
  - два алгоритма обхода
  - как минимум один алгоритм поиска кратчайшего пути
  - методы для работы с вершинами и рёбрами: добавление, удаление, редактирование
  - документируйте код, указывайте сложность алгоритмов для трёх классов входных данных, пишите поясняющие комментарии
  - сохранение\загрузка в файл (рекомендуется использовать распространённый формат, например GraphML)
2. Напишите тесты.
3. *Бонус. Создайте текстовую РПГ. Для хранения набора локаций\ситуаций используйте граф или дерево. Можно использовать изображения, звук и видео для локаций.*
4. *Бонус. Протестируйте работу алгоритмов поиска кратчайшего пути на графах, описывающих сеть улиц знакомого вам города* (https://stackoverflow.com/questions/69174361/how-to-extract-street-graph-or-network-from-openstreetmap)

### Домашнее задание. Сетевой анализ
1. Сетевой анализ в Gephi
   - Загрузите и визуализируйте граф как минимум из нескольких сотен узлов и ребёр. См. наборы данных ниже.
   - Что является вершиной, а что является дугой\ребром в этом графе? Покажите таблицу или фрагмент таблицы с данными.
   - Вычислите позиционные характеристики для узлов (degree, closeness, betweenness centrality). Задайте размер узлов в зависимости от количества связей.
   - Найдите в графе кластеры. Раскрасьте их.
   - Вычислите для каждого узла
      - Degree centrality, Betweenness Centrality, Closeness Centrality
   - Составьте отчёт о проделанной работе

Короткая справка: https://docs.google.com/document/d/17bFJGKh9ZTmzU-CpM6JDtfFn17YvdWjlduGbSTAQU5A \
Визуализация графов в gephi: https://sysblok.ru/knowhow/kak-plesti-virtualnye-seti-s-pomoshhju-gephi/

Работу можно выполнять используя специализированые пакеты Python вместо Gephi.

Наборы данных:
- https://github.com/gephi/gephi/wiki/Datasets
- http://snap.stanford.edu/data/


2. *Бонус: Постройте граф друзей для произвольного профиля ВК или любой другой социальной сети*:
   - https://vk.com/app6747909_-173786471?section_type=public_r_app
   - id или никнейм пользователя вводится по клику на аватарку справа вверху
   - Можно использовать любой другой инструмент, для визуализации и построения социальных графов
   - Бонусные баллы за использование инструмента, который создаёт graphml или любой другой файл на основе социального графа

3. *Бонус: постройте взвешенный граф и его матрицу смежности для некоторых аудиторий энергетического факультета.* Узлы - аудитории кафедры, комп. классы, столовая, главный вход, гардероб. Можно добавить узлы на своё усмотрение.

# Лекция 7-8. Графы
29 октября, 5 ноября
- Слайды: https://docs.google.com/presentation/d/1rAm62F6-SPpE-8sxhBOcsRWrK-2M4CJ03DmkZeEENts/edit?usp=sharing


# Лекция 6. АВЛ-деревья, двойной поворот. Деревья решений
22 октября
- Повторение.
- АВЛ деревья [[слайды](https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit#slide=id.g2911c960b97_0_0)]
   - Двойной поворот.
- Применение деревьев: Алгоритм машинного обучения Дерево решений. [[слайды. коротко](https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit#slide=id.g285d4f20cf1_0_34)]
   -  Назначение. Применение. Узлы и листья. Пример.


### Домашнее задание. Конспекты
- Красно-чёрное дерево
- М-арное дерево
- B-дерево
- Декартово дерево
- Splay дерево
- 2-3 дерево


# Лекция 5. АВЛ-деревья
15 октября
- Повторение.
- АВЛ деревья [[слайды](https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit#slide=id.g2911c960b97_0_0)]
   - Назначение. Баланс узла. Левый и правый поворот. Примеры. Операции вставки и удаления. Пример интерфейса класса АВЛ дерева.


### Домашнее задание. АВЛ-дерево
- Реализуйте класс AVL tree. Используйте созданные ранее классы в качестве основы.
- *Бонус: определите интерфейс для классов BST и АВЛ дерево*
- Скачайте программу Gephi: https://gephi.org/


# Лекция 5. Итераторы. Куча (heap)
8 октября
- Повторение.
- Итераторы. Продолжение. Итераторы в Java и C#
- Слайды: https://docs.google.com/presentation/d/19OpCSfT8RM0c-lcAHhLHUM8s7jXqf_skliTnSj3RCCg/edit?usp=sharing
- Куча. Правило хранения данных. Операции. Их сложность.
- Пирамидальная и турнирная сортировка.
- Слайды: https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit#slide=id.g27b440caead_0_59

### Задание. Куча
Реализуйте шаблонный класс для кучи (min-heap или max-heap).
- Данные храните в массиве. Предусмотрите доступ к нему.
- Документируйте код, пишите поясняющие комментарии, указывайте сложность для основных операций АТД куча.
- Пишите тесты. Используйте функции и классы стандартной библиотеки для тестирования.
- *Бонус: создайте функцию\метод, который строит бинарное дерево из узлов (экземпляров TreeNode) на основе массива, в котором записана куча*

Закончите до 23 октября.


### Задание (бонус). Очередь приоритетов
Реализуйте класс для очереди приоритетов.
Для хранения данных используйте кучу.



### Задание. Сортировка кучей и турнирная сортировка
1. Реализуйте сортировку с помощью кучи.
2. Бонус: Реализуйте турнирную сортировку.
2. Создайте тесты.
3. Постройте график работы алгоритмов. Сравните со временем работы алгоритмов сортировки, реализованными в прошлом семестре.



# Лекция 4. Итераторы
1 октября
- Указатели и адресная арифметика.
- Понятие итератора. Итераторы в STL. Итераторы и цикл по коллекции. Методы begin и end.
- Примеры интерфейса итератора.
- Слайды: https://docs.google.com/presentation/d/19OpCSfT8RM0c-lcAHhLHUM8s7jXqf_skliTnSj3RCCg/edit?usp=sharing
   - Пример итератора для массива.


### Задание. Итераторы
1. Создайте пример использования функций из модуля algorithms: for_each, any_of \ all_of \ none_of, transform, copy_if
1. Разработайте итератор для класса списка (LinkedList).
2. Разработайте итератор для класса Бинарное дерево поиска.
3. *Бонус: Используйте цикл по коллекции `for( x : collection)` для перебора элементов. Протестируйте итераторы для LinkedList и BST с в том числе с использованием алгоритмов for_each, transform, и других*

Документируйте код. Пишите поясняющие комментарии. Создавайте тесты.


# Лекция 2-3. Бинарное дерево поиска
10 сентября, 24 сентября
- Повторение
- Операции поиска, вставки и удаления
- Пример класса с оператором сравнения
- Сложность операций?
Слайды: https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit?usp=sharing

### Задание. Бинарное дерево  поиска
- Реализуйте бинарное дерево поиска. Создайте тесты.
- upd: Дополните документацию оценкой сложности алгоритма BigO
- upd: постройте графики времени поиска в
   - сортированном массиве
   - BST
- *Бонус: показать операции BST на примере данных в виде произвольного класса с операторами (методами) сравнения.*

# Лекция 1. Повторение. Деревья
03 сентября
1. Повторение:
   - Сложность алгоритмов. Рекурсия.
   - Интерфейс, АТД.
   - Списки.
   - Стек. Очередь. Дек. Очередь с приоритетом.
   - Множество
   - Слайды: https://docs.google.com/presentation/d/1YEXijE-L6xtoXNAgLldPDsw_skUCQwc7e4XA5dC0obk/edit?usp=sharing
2. Обзор тем и заданий семестра
2. Деревья.\
Слайды: https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit?usp=sharing


### Задание Узел бинарного дерева
1. Разработать шаблонный класс TreeNode для представления *узла* бинарного дерева
    - Создать бинарное дерево из 5+ узлов, используйте динамическое выделение памяти;
    - Изобразить дерево любыми средствами (можно нарисовать прямо в коде);
    - Является ли дерево строгим, законченным (complete) или совершенным (perfect)?
    - Посмотреть содержимое любого из узлов;
    - Удалить все узлы.
2. Создать тестовые функции.
5. *Бонус: добавьте возможность экспорта дерева в файл одного из популярных форматов описания графов (например [DOT language](https://graphviz.org/doc/info/lang.html) или [GraphML](http://graphml.graphdrawing.org/primer/graphml-primer.html)).*
3. *Бонус: аналогично создайте структуру для узла n-арного дерева*
4. *Бонус: создайте программу для визуализации произвольных бинарных деревьев. Можно создать приложение на JavaScript*\
   *Программа может иметь GUI или может создавать изображения (например SVG).*

<details>

Пример содержимого SVG файла. Сохраните это в файл с расширением svg чтобы просмотреть изображение.


```text
<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">

<ellipse cx="400" cy="50" rx="80" ry="20" stroke="black" stroke-width="3" fill="white" />
<text x="400" y="54" font-size="12" text-anchor="middle"> Root </text>
<line x1="400" y1="70" x2="200" y2="130" stroke="black" stroke-width="3" />

<ellipse cx="200" cy="150" rx="80" ry="20" stroke="black" stroke-width="3" fill="white" />
<text x="200" y="154" font-size="12" text-anchor="middle"> Left </text>
<line x1="200" y1="170" x2="100" y2="230" stroke="black" stroke-width="3" />

<ellipse cx="100" cy="250" rx="80" ry="20" stroke="black" stroke-width="3" fill="white" />
<text x="100" y="254" font-size="12" text-anchor="middle"> Left.Left </text>
<line x1="200" y1="170" x2="300" y2="230" stroke="black" stroke-width="3" />

<ellipse cx="300" cy="250" rx="80" ry="20" stroke="black" stroke-width="3" fill="white" />
<text x="300" y="254" font-size="12" text-anchor="middle"> Left.Right </text>
<line x1="400" y1="70" x2="600" y2="130" stroke="black" stroke-width="3" />

<ellipse cx="600" cy="150" rx="80" ry="20" stroke="black" stroke-width="3" fill="white" />
<text x="600" y="154" font-size="12" text-anchor="middle"> Right </text>

</svg>
```


Шпаргалка по SVG: http://shpargalkablog.ru/2015/11/svg.html

</details>


Закончите до 9 сентября


### Задание Алгоритмы для бинарного дерева
1. Реализовать три алгоритма обхода (NLR, LNR, LRN).
   Оформите алгоритмы в виде функций:
   - создания массива (списка) на основе обхода;
   - вывода содержимого узлов дерева;
   - применения функции к каждому узлу дерева. [https://en.cppreference.com/w/cpp/utility/functional/function]
   - upd: Бонус. Реализуйте алгоритм обхода в ширину  (см. следующие лекции)
   - upd: Бонус. Реализуйте не рекурсивный алгоритм обхода в глубину (см. следующие лекции)
   - upd: Бонус. Реализуете операцию поиска в бинарном дереве. Укажеите BigO для операции.
   - upd: Бонус. Постройте графики времени обхода бинарного дерева рекурсивным и нерекурсивным алгоритмами в зависимости от размера дерева.
   ...
2. На основе изученных алгоритмов обхода создайте
   - функцию удаления дерева
   - функцию подсчёта узлов
   - функцию определения глубины дерева
   - функции печати данных дерева:
     - в произвольном порядке
     - в виде дерева [1]
4. Создайте тесты для функций. Рассмотрите различные варианты деревьев, крайние случаи: пустые деревья, деревья из одного узла, вырожденные деревья и т.д.
5. Документируйте код, BigO для операций
6. *Бонус: аналогично создайте алгоритмы для n-арного дерева*
5. *Бонус: опишите любую иерархическую структуру на основе собственного класса.*
   - реализуйте алгоритм обхода с применением функции к данным каждого узла
   - дополнительно: используйте узлы с произвольным числом потомков


Закончите до 16 сентября
