# САОД

# Лекции 1. Повторение. Деревья.
- C++: [OOP StudBook](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook_upd.pdf)
- Алгоритмы. Сложность алгоритмов. 
https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing
- Деревья
https://docs.google.com/presentation/d/13iV3yhsT4afPxKIsdVpDKxIU_fr4u2gPb4MdQ7VP51E/edit?usp=sharing



# Задание 1
Тема: Деревья. Бинарные деревья поиска. Алгоритмы обхода дерева.
Источник: [4] У. Топп, У. Форд. Структуры данных в С++: Пер. с англ. – М.:
ЗАО «Издательство БИНОМ», 1999, 816с. §11.1; 11.2; 11.3; 11.6

- Реализовать шаблонный класс TreeNode и построить с его помощью бинарное
дерево для списка <int> 30,50, 25, 70, 40.
- Реализовать рекурсивные функции обхода деревьев (либо LNR, RNL); 
    - печать узлов дерева 
    - заполнение динамического массива
- Реализовать шаблонный класс BinSTree, без метода удаления узла, и показать работу его методов (вставка данных, поиск данных, очистка всего дерева, глубина дерева, количество узлов в дереве), в частности, печать узлов для методов обхода дерева.
- Дополнительно:
    - Функция удаление узла из бинарного дерева
    - Метод удаления узла из бинарного дерева поиска \ АВЛ дерева
    - Построить график времени работы метода поиска для бинарного дерева поиска и АВЛ дерева для разных размеров деревьев. Максимальное время поиска должно быть как минимум порядка секунд. Похожи ли графики времени на оценку сложности BigO для этой операции?


# Задание 2
Тема: Сбалансированные деревья. AVL-деревья.
Источник: [4] У. Топп, У. Форд. Структуры данных в С++: Пер. с англ. –
М.: ЗАО «Издательство БИНОМ», 1999. – 816 с. § 13.5; 13.6
- Реализовать класс AVLTree
- Построить [в программе] AVL-дерево для последовательности <int> 30, 50, 25, 70, 60, 40, 55, 45, 20.
- Вывести его на печать, используя класс BinSTree.



**Генерация случайных чисел в C++**
```C++
#include <random>   // библиотека для генерации случайных чисел


    // Объект для доступа к аппаратному или программному источнику случайности
    // нужен для инициализации генератора случайных чисел
    std::random_device rd; 
 

    // Объект - генератор случайных чисел с seed (начальным значением) от random_device
    std::mt19937 gen(rd());
    // Если не требуется действительно случайной инициализации генератора, 
    // то можно создать генератор так:
    std::mt19937 gen( time() );
    // Если нужна воспроизводимость последовательности, то нужно инициализировать константой
    std::mt19937 gen( 42 );

    // Объект, отвечающий за конкретные парамеры (вид распределения, его параметры)
    // выдаваемых случайных значений
    std::uniform_int_distribution<> distr(-1'000'000'000, 1'000'000'000);
    // для равномерного (uniform) распределения указываются параметры: минимум и максимум

    for (int n = 0; n < 10; ++n) {
        std::cout << distr(gen) << ' ';     // генерация и вывод случайных чисел
    }
    std::cout << std::endl;
```


`mt19937` - генератор на основе Вихря Мерсена (Mersenne Twister). Он может выдывать последовательность случайных чисел, которая имеют период повторяемости  $2^{19937}-1$.