# Структуры и алгоритмы обработки данных

# Результат успешного прохождения курса
- Научитесь использовать оценку сложности алгоритмов BigO
- Изучите и реализуете алгоритмы поиска в последовательностях
- Изучите и реализуете алгоритмы сортировки последовательностей
- Познакомитесь с динамическими алгоритмами
- Познакомитесь с некоторыми алгоритмами обработки строк
- На практике примените многие концепции ООП, шаблонного программирования, модульного тестирования
- Изучите структуры данных изнутри, их сильные и слабые стороны, кейсы применения, реализуете эти структуры в виде классов
    - Динамический массив
    - Списки
    - Стек
    - Очередь
    - Дерево, бинарное дерево, бинарное дерево поиска
    - AVL дерево
    - Граф
    - Хеш-таблица
    - Словарь
    - ...
- ...


# План
## Лекция 1. Обзор курса. Сложность алгоритмов.
Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing


## Занятие 1.
Защита работ по ООП (если не сданы).

### Задание 0.
1. Раздобудьте рекомендованную литературу.

2. Если будете выполнять работы не на языке C++, то раздобудьте литературу по этому языку программирования. Там должны быть описаны основы языка: основы синтаксиса, типы данных, основные операторы, функции, методы, классы, модули, шаблонные классы и функции (или аналоги шаблонов), анонимные функции.

### Задание 1. Подготовительный код для работы с массивами, измерения времени; последовательный поиск
Используйте язык программирования С++. 
Документируйте код, указывайте автора, пишите поясняющие комментарии, не пишите весь код в одном файле. Привидите ссылку на это задание в главной файле программы, текст задания.
Для хранения размера массива, индексов стоит использовать тип `size_t`. Он может хранить только положительные значения из большого диапазона. 



1. Напишите подготовительный код, используйте шаблонные функции:
    - Шаблон кода для измерения времени работы участка кода. [OOP_StudBook.pdf: Время](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10)
    - Функцию создания массива заданного размера, заполненного случайными значениями в заданном интервале. [OOP_StudBook.pdf](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10)
    - Функцию вывода массива в файл.
    - Функцию, которая проверяет, отсортирован ли массив; напишите автоматические тесты для функции (assert).
    - *Дополнительно: для тестов используйте тестовый проект (например, на основе google test) в среде разработки.*
1. Реализуйте алгоритм последовательного поиска значения в массиве используя шаблонные функции. 
    - Протестируйте их на массивах большого размера. Измерьте время выполнения в зависимости от размера массива. Время должно быть как минимум порядка секунд, иначе результаты нельзя считать надёжными. На время выполнения вашей программы могут сильно влиять другие программы, работающие одновременно с ней. Запускайте операции несколько раз (в цикле) чтобы получить более надёжные измерения времени.
    - Приведите оценки сложности Big O реализованных алгоритмов для лучшего, среднего и худшего случая. Приведите графики этих оценок. Как сильно они отличаются от полученных?


**Измерение времени работы кода**
```cpp
#include <chrono>
using namespace std::chrono;


	auto t0 = steady_clock::now();
	
	// конечная отметка времени
	auto t1 = steady_clock::now();
	// преобразование времени (обычно наносекунды) в миллисекунды
	auto delta = duration_cast<milliseconds>(t1 - t0);
	std::cout << "time delta (milliseconds) " << delta.count()
```


Можно использовать этот пример кода на Питоне для построения графиков
```python
import matplotlib.pyplot as plt
import seaborn # pip install seaborn

plt.figure( figsize=(15, 10) )
plt.title("Среднее время работы сортировок")
plt.plot( [10, 100, 1000], [1, 2, 8], 'o--', label = "название сортировки 1" )
plt.plot( [10, 100, 1000], [2, 2, 9], 'o--', label = "название сортировки 2" )
plt.plot( [10, 100, 1000], [0.3, 3, 10], 'o--', label = "название сортировки 3" )
plt.grid(True)
plt.xlabel('размер массива')
plt.ylabel('среднее время (ед. измер)')
plt.legend(loc = 'best')
```
Для построения графиков можно использовать среду [google colaboratory](https://colab.research.google.com/) (требуется войти в аккаунт google).



### Задание 2. Анализ сложности алгоритма.
Привидите ссылку на это задание в главной файле программы, текст задания.
[tasks/task_s1_alg_analysis](../tasks/task_s1_alg_analysis.md)



## Лекция 2. Рекурсия. Алгоритмы поиска
14 февраля
0. Повторение. Опрос. Оценка сложности алгоритмов. BigO. Классы сложности. Классы входных данных.
1. Рекурсия.
2. Рекурсия. Алгоритмы поиска.


Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing

### Задание 3. Бинарный поиск.
Привидите ссылку на это задание в главной файле программы, текст задания.
1. Реализуйте алгоритм бинарного поиска.
2. Напишите тесты.
3. Постройте графики времени работы алгоритма. Сравните его с алгоритмом последовательного поиска.
4. Бонус: добавьте в программу интерфейс, использующий аргументы командной строки, для ввода входных данных или параметров их генерации.


Используйте код, созданный для задания 1.


### Задание 4. Размер стека вызовов
Оцените размер стека вызовов на своём компьютере. Создайте отчёт.

### Задание 5. [Рекурсия](../tasks/task_recursion.md)


## Лекция 3. Подходы к построению алгоритмов.
20 февраля
1. Повторение. Опрос. Время выполнения операций [ [слайд](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g2ba866ef3bc_0_0) ]
1. Жадные алгоритмы [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15) ].
1. Динамическое программирование [ [слайды](https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit#slide=id.g1f2025a2af7_0_15)].


### Домашнее задание (бонус). Mind map
К концу семестра создайте интиллект карту (mind-map), отражающую структуру дисциплины, важные понятия, литературу и другие источники.
Используйте изображения, схемы, ссылки, формулы, цветовое кодирование и т.д.

Создавайте диаграмму в специальной программе (онлайн-приложении), например  draw.io


### Задание 6. Жадные алгоритмы?

### Задание 7. Динамическое программирование?

### Задание. Список?

### Задание. Стек?

### Задание. Очередь?

### Задание. Поразрядная сортировка?

### Задание. Алгоритмы поиска в строке?

### Задание 11. Дек (deque)?