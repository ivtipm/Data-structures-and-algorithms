# Структуры и алгоритмы обработки данных

# Результат успешного прохождения курса
- Научитесь использовать оценку сложности алгоритмов BigO
- Изучите и реализуете алгоритмы поиска в последовательностях
- Изучите и реализуете алгоритмы сортировки последовательностей
- Познакомитесь с динамическими алгоритмами
- Познакомитесь с некоторыми алгоритмами обработки строк
- На практике примените многие концепции ООП, шаблонного программирования, модульного тестирования
- Изучите структуры данных изнутри, их сильные и слабые стороны, кейсы применения, реализуете эти структуры в виде классов
    - Динамический массив
    - Списки
    - Стек
    - Очередь
    - Дерево, бинарное дерево, бинарное дерево поиска
    - AVL дерево
    - Граф
    - Хеш-таблица
    - Словарь
    - ...
- ...


# План
## Лекция 1. Сложность алгоритмов. Рекурсия. Алгоритмы поиска
Слайды: https://docs.google.com/presentation/d/1ofbDxk9cbT4ABdCmGFqftz3u166DV1KkrJGU_Z7E6Kg/edit?usp=sharing

### Задание 2. Размер стека вызовов.
Оцените размер стека вызовов на своём компьютере. Создайте отчёт. 

### Задание 3. Анализ алгоритмов.


### Задание 3. Бинарный поиск.
1. Реализуйте алгоритм бинарного поиска.
2. Напишите тесты.
3. Постройте графики времени работы алгоритма. Сравните его с алгоритмом последовательного поиска.

Используйте код, созданный для задания 1.


## Занятие 1.
Защита работ по ООП (если не сданы).

### Задание 0.
Раздобудьте рекомендованную литературу.

### Задание 1. Подготовительный код для работы с массивами, измерения времени; последовательный поиск
Используйте язык программирования С++. 
Документируйте код, указывайте автора, пишите поясняющие комментарии, не пишите весь код в одном файле.

1. Напишите подготовительный код, используйте шаблонные функции:
    - Шаблон кода для измерения времени работы участка кода. [OOP_StudBook.pdf: Время](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10)
    - Функцию создания массива заданного размера, заполненного случайными значениями в заданном интервале. [OOP_StudBook.pdf](https://raw.githubusercontent.com/VetrovSV/OOP/master/OOP_StudBook.pdf#section.3.10)
    - Функцию вывода массива в файл.
    - Функцию, которая проверяет, отсортирован ли массив; напишите автоматические тесты для функции (assert).
    - *Дополнительно: для тестов используйте тестовый проект (например, на основе google test) в среде разработки.*
1. Реализуйте алгоритм последовательного поиска значения в массиве используя шаблонные функции. 
    - Протестируйте их на массивах большого размера. Измерьте время выполнения в зависимости от размера массива. Время должно быть как минимум порядка секунд, иначе результаты нельзя считать надёжными. На время выполнения вашей программы могут сильно влиять другие программы, работающие одновременно с ней. Запускайте операции несколько раз (в цикле) чтобы получить более надёжные измерения времени.
    - Приведите оценки сложности Big O реализованных алгоритмов для лучшего, среднего и худшего случая. Приведите графики этих оценок. Как сильно они отличаются от полученных?

Можно использовать этот пример кода на Питоне для построения графиков
```python
import matplotlib.pyplot as plt
import seaborn # pip install seaborn

plt.figure( figsize=(15, 10) )
plt.title("Среднее время работы сортировок")
plt.plot( [10, 100, 1000], [1, 2, 8], 'o--', label = "название сортировки 1" )
plt.plot( [10, 100, 1000], [2, 2, 9], 'o--', label = "название сортировки 2" )
plt.plot( [10, 100, 1000], [0.3, 3, 10], 'o--', label = "название сортировки 3" )
plt.grid(True)
plt.xlabel('размер массива')
plt.ylabel('среднее время (ед. измер)')
plt.legend(loc = 'best')
```
Для построения графиков можно использовать среду [google colaboratory](https://colab.research.google.com/) (требуется войти в аккаунт google).



